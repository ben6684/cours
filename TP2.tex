\documentclass[11pt,twoside,a4paper]{report}
%=========================== En-Tete =================================
%--- Insertion de paquetages (optionnel) ---
\usepackage[french]{babel}   % pour dire que le texte est en franÃ§ais
\usepackage{a4}              % pour la taille   
\usepackage[latin1]{inputenc}     % pour les font postscript
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{amsmath} 
\usepackage{url}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{xcolor}


\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{mygreen}{rgb}{0,0.6,0}

\begin{document}
\lstset{%
backgroundcolor=\color{lightgray}, 
basicstyle=\footnotesize,
commentstyle=\color{mygreen},
breaklines=true,
frame=single,
keepspaces=true,
keywordstyle=\color{blue},
language=Python,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{black},
stringstyle=\color{mymauve}, 
xleftmargin=\parindent,
tabsize=3,
}%

\chapter{TP n°2}

\section{Problématique}


La manière de faire des requêtes de type SQL sur des ensembles de données non-structuré a été abordé dans le chapitre précédent et a posé les bases de l'écriture d'algorithme MapReduce.\\

Il parait clair que les problématiques BigData se scindent en deux grandes catégories:
\begin{enumerate}
\item \underline{Technologique}, car pour faire du BigData, il faut un ensemble d'infrastructures matériels (Cluster, Amazon EC2, EMR, ...) et logiciels (Hadoop, NoSQL databases, ...). Qui ont pour points commun d'être en perpetuelle évolution et d'avoir une littérature plutôt bien fournie sur le net.
\item \underline{Algorithmique}, car pour pouvoir faire du BigData, il faut pouvoir intéragir avec les données dans l'ensemble des infrastructures. Pour cela, la création d'algorithmes MapReduce est nécessaire. Des alternatives existent (Scala, Mahout, Hive ...) pour pouvoir manipuler les données sans passer par l'écriture d'algorithmes MapReduce, mais ne permettent pas des traitements avancés et personalisés.
\end{enumerate}

Il semble clair, qu'une étude approfondie des possibilités algorithmiques MapReduce reste encore à faire. Le net dans ce cas précis manque singulièrement de littératures sauf si vous compter compter des mots encore et encore.\\

Le cout de compréhension du paradigme MapReduce est encore trop grand pour que les chercheurs et ingénieurs aient approfondis le sujet.\\

Voilà pourquoi le cours sur MapReduce prend la place d'un simple cours sur les technologies BigData.\\

\section{Bases de statistique}

\subsection{Exercice 1}

Calcul de le prix de la vente moyenne.\\

En SQL :\\
 
\begin{lstlisting}
SELECT AVG(prix) FROM client;
\end{lstlisting}
 
En Math :\\
\begin{align}
\overline{X} = \frac{1}{n} \sum_{i=1}^{n} x_i
\end{align}

Indication : Vous devez connaître la somme des prix ET le nombre de vente

\subsubsection{Corrigé}

Plusieurs solutions sont possibles : \\

\begin{itemize}
\item la première solution que je vois et d'envoyer en sortie du mapper la clef nulle, pour récupérer sur un seul reduceur la liste des valeurs. Ainsi il suffit de sommer les valeurs et de la diviser par la taille de la liste.\\

\begin{lstlisting}
def mapper()
\end{lstlisting}

\item La deuxième solution est d'utiliser un combiner, 

\item La troisième est d'enchainer deux job map-rduce

\end{itemize}


\end{document}
